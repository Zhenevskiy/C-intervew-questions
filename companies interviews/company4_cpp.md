## Вопросы на собеседовании в компании 4

Это было собеседование по опыту работы и обзорное по с++.
Вот примеры вопросов из него

1. Какой самый сложный шаблонный код ты писал? 

Как пример: контейнер, в котором элементы имеют шаблонный тип.

2. Что такое CRTP (curiously recurring template pattern)?
Для чего он используется? В чем его преимущества и недостатки? 

Ответ: CRTP - идиома языка C++, состоящая в том, что некоторый класс X наследуется от шаблона класса, использующего X как шаблонный параметр.

```cpp
template <class T> 
struct Base
{
    void interface()
    {
        // ...
        static_cast<T*>(this)->implementation();
        // ...
    }

    static void static_func()
    {
        // ...
        T::static_sub_func();
        // ...
    }
};

struct Derived : Base<Derived>
{
    void implementation();
    static void static_sub_func();
};
```

Используется для того, чтобы реализовать статический 
полиморфизм, в то время как использование виртуальных
функций - это динамический полиморфизм.

Преимущества: CRTP реализует статический 
полиморфизм,
который быстрее, чем динамический полиморфизм.

Недостатки: нельзя выбрать нужную реализацию
переопределенного метода во время выполнения. Другими
словами, если при использовании виртуальных функций мы могли
бы сделать вектор ```vector<Base*>```, в котором
одни элементы имеют тип ```Base*```, а другие - тип
```Derived*```, то мы можем вызвать метод в цикле
(код сам пойдем, какую реализацию выбрать), то при CRTP
так не получится.

3. С чем работать быстрее: 
```struct{vector<int>, vector<int>}``` 
или с ```vector<struct{int, int}>```.
Почему?

Ответ (возможно правильный):
быстрее работать с ```struct{vector<int>, vector<int>}```,
так как в этом случае элементы массивов лежат рядом,
и будет меньше промохов по кешам.

4. Представим, что есть программа, которая падает
каждый раз в случайном месте. Как ее отладить?

5. Что происходит, когда у ```std::vector``` нет свободного
невыделенного места (```size == capacity```)? 
Как сделать так, чтобы при релокации вызывался ```std::move```
вместо обычного копирования?

Ответ: Для того, чтобы вызывался ```std::move```,
необходимо конструктор перемещения у объектов вектора пометить
как ```noexcept```.


6. В общем случае виртуальные функции
медленнее, чем невиртуальные. Но что может сделать 
компилятор, чтобы улучшить ситуацию в этом случае 

Ответ: девиртуализация

7. У нас есть вектор объектов, и мы у каждого объекта 
вызываем виртуальную функцию. Почему в этом случае будут проблемы
с векторизацией.


